char *a 与char a[]所占空间解析
-------------
###### 在分析之前，我们先熟悉下在16位、32位、64位下指针类型 与char类型所占空间
         16位        32位       64位
    char 1           1          1
    指针  2           4          8（我们在有的编译环境下面sizeof出来是4 是因为编译器为了编译32位机器代码而做的妥协，按道理上是8位）

ok,让我们开始测试并分析如下各种情况
###### 如下
假设我们的程序（64位机器）如下：


```c
void countsize(char a[])  
{  
  
    cout<< sizeof a ;  
  
} 
int main(){
    char a[]="hello";
    char *b = "hello";
    char c[10]="hello";
}

```
siezeof(a)==6, sizeof(b)==4, sizeof(*b)==1, sizeof(c)=10  
因为a的结尾还有一个字符串结束符'\0'所以一共有6个字节
同时 b是一个指针 无论如何都是4， 但是*可以理解为一个地址类型，b才存放着另外一个变量的地址所以输出为1
，c已经指定了大小 则输出为10.

特别有意思的是 countsiz(a)==4 countsize(b)==4 countsize(c)==4 其实coutsize(char a[])与coutsize(char *a)是一样的，它是不会为你记录数组的大小，而是传入了地址参数。
#### 关于字符数组的长度问题(sizeof与strlen)
###### strlen
     strlen函数遇到'\0'结束统计并返回。
```c
    char chs0[7] = {'a', 'c', '0', 'z', '3','d'}; // 长度为6, 在末尾自动加上了'\0'
    
    char chs1[7] = {'a', 'c', '0', 'z', '3','d', '/0'}; // 长度为6
    
    char chs2[] = {'a', 'c', '0', 'z', '3','d', '/0' }; // 长度为6
    
    char chs3[] = {'a', 'c', '0', 'z', '3','d'}; // 长度未知，因为数组最后没有结束符'/0'
    
    char chs4[6] = {'a', 'c', '0', 'z', '3','d'}// 长度未知，因为数组最后没有结束符'/0'

```
char c[]={'c', ' ','p','r','o','g','r','a','m'};

 可写为：
 
   char c[]={"C program"};
   
或去掉{}写为：

   char c[]="C program";
   
   用字符串方式赋值比用字符逐个赋值要多占一个字节， 用于存放字符串结束标志'/0'。
###### sizeof
       sizeof就是计算所占字节长度
     

###### 如果有错误欢迎指正 感谢 比心

#### [返回主页](http://Lucas-Yang.github.io)
